using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using Microsoft.VisualBasic;
using System.IO;
using System.Text.RegularExpressions;

namespace RetroRPGLevelEditor2
{
    public partial class Form1 : Form
    {
        int prevX = -1;
        int prevY = -1;
        string tempCode = "";
        bool highlightCreation = false;

        int renderXSize = 33;
        int renderYSize = 22;

        int mapWidth = 128;
        int mapHeight = 128;

        int cameraXMin = 0;
        int cameraYMin = 0;
        int cameraXMax = 33;
        int cameraYMax = 22;

        int zoomFactor = 32;

        int mouseX = 0;
        int mouseY = 0;

        int animationSpeed = 3;
        int animationOffset = 200;

        Rectangle rec = new Rectangle();
        Tile tempTile;

        // Root nodes
        AdvancedNode terrainNode = new AdvancedNode("Terén");
        AdvancedNode itemNode = new AdvancedNode("Předměty");
        AdvancedNode actorsNode = new AdvancedNode("Postavy");


        public class Tile
        {
            static int tempID = 100;

            public Tile(status t, Color b, Rectangle r, Bitmap image)
            {
                tile = t;
                brush = b;
                rectangle = r;

                id = tempID;
                tempID++;
                this.image = image;

            }

            public status tile;
            public Color brush;
            public Rectangle rectangle;
            public int id;
            public string creationCode = "// This code is generated by LoF\n//Creation code for object: " + tempID + "\n";
            public Bitmap image;
        }

        public enum status
        {
            free, wall, moveableWall, player, item, coin, enemy
        };

        status[,] grid;
        public List<Tile> pointList = new List<Tile>();
        SizeF size = new SizeF(32, 32);
        Bitmap contentWall = new Bitmap("wall.png");
        Bitmap contentMoveableWall = new Bitmap("wallMoveable.png");
        Bitmap contentCoin = new Bitmap("coin.png");
        Bitmap free = new Bitmap("free.png");
        Bitmap contentPlayer = new Bitmap("player.png");

        public Form1()
        {
            InitializeComponent();
            this.Focus();
            this.KeyPreview = true;
            oCamera.Top += 50;
            comboBox1.SelectedItem = "Zeď";
            Pos pos = new Pos(0, 0, "Začátek úrovně (0,0)");
            oBookmarks.Items.Add(pos);
            oBookmarks.SelectedItem = oBookmarks.Items[0];
            AddNodes();

            hScrollBar1.Maximum = mapWidth - renderXSize;
            vScrollBar1.Maximum = mapHeight - renderYSize;

            grid = new status[mapWidth, mapHeight];
            for (int y = 0; y < mapHeight; y++)
            {
                for (int x = 0; x < mapWidth; x++)
                {
                    grid[x, y] = status.free;
                }
            }

            for (int y = 0; y < mapHeight; y++)
            {
                for (int x = 0; x < mapWidth; x++)
                {
                    Rectangle rec = new Rectangle(new Point(x * 32, y * 32), size.ToSize());
                    Tile tile = new Tile(status.free, Color.Black, rec, free);
                    pointList.Add(tile);
                }
            }
        }


        private void oAddWall_Click(object sender, EventArgs e)
        {

            PictureBox picBox = new PictureBox();
            picBox.Location = new Point(MousePosition.X, MousePosition.Y);
            Controls.Add(picBox);
        }

        public void ShowMyDialogBox(Tile tile, Form1 form, int tileIndex)
        {
            Form2 testDialog = new Form2(form, tileIndex);
            testDialog.input.Text = tile.creationCode;
            // Show testDialog as a modal dialog and determine if DialogResult = OK.
            if (testDialog.ShowDialog(this) == DialogResult.OK)
            {
                // Read the contents of testDialog's TextBox.
                tile.creationCode = testDialog.input.Text;
            }
            else
            {
                tile.creationCode = testDialog.input.Text;
            }
            testDialog.Dispose();
        }

        void HandleMouseClick(object sender, MouseEventArgs e)
        {
            int x = (PointToClient(Cursor.Position).X / zoomFactor) + cameraXMin;
            int y = (PointToClient(Cursor.Position).Y / zoomFactor) + cameraYMin;

            // Normalizace
            x = Math.Max(Math.Min(x, mapWidth - 1), 0);
            y = Math.Max(Math.Min(y, mapHeight - 1), 0);

            Tile tile = pointList[y * mapHeight + x];

            if (e.Button == MouseButtons.Left && Control.ModifierKeys == Keys.None)
            {
                if (tile.tile == status.free)
                {
                    if (comboBox1.SelectedIndex == (int)objects.Wall)
                    {
                        grid[x, y] = status.wall;
                        pointList[y * mapHeight + x].tile = status.wall;
                        tile.image = contentWall;
                    }
                    if (comboBox1.SelectedIndex == (int)objects.MoveableWall)
                    {
                        grid[x, y] = status.moveableWall;
                        pointList[y * mapHeight + x].tile = status.moveableWall;
                        tile.image = contentMoveableWall;
                    }
                    if (comboBox1.SelectedIndex == (int)objects.Coin)
                    {
                        grid[x, y] = status.coin;
                        pointList[y * mapHeight + x].tile = status.coin;
                        tile.image = contentCoin;
                    }
                    if (comboBox1.SelectedIndex == (int)objects.Player)
                    {
                        grid[x, y] = status.player;
                        pointList[y * mapHeight + x].tile = status.player;
                        tile.image = contentPlayer;
                    }
                }
                else
                {
                    grid[x, y] = status.free;
                    pointList[y * mapHeight + x].tile = status.free;
                    tile.image = free;
                }
            }

            if (e.Button == MouseButtons.Left && Control.ModifierKeys == Keys.Shift)
            {
                grid[x, y] = status.free;
                pointList[y * mapHeight + x].tile = status.free;
                tile.image = free;
            }


            if (e.Button == MouseButtons.Right)
            {
                ShowMyDialogBox(tile, this, y * mapHeight + x);
            }
        }

        private void Form1_MouseClick(object sender, MouseEventArgs e)
        {
            if (prevX == -1 && prevY == -1)
            {
                HandleMouseClick(sender, e);
            }

            //MessageBox.Show("x: " + x.ToString() + "\ny: " + y.ToString());


        }

        private void Form1_Paint(object sender, PaintEventArgs e)
        {
            DrawLShapeLine(e.Graphics, 10, 10, 20, 40);
            DrawGrid(e.Graphics);

            Pen myPen = new Pen(new SolidBrush(Color.FromArgb(128, 0, 0, 0)));
            myPen.Width = 4;
            e.Graphics.DrawRectangle(myPen, rec);
        }

        public void DrawLShapeLine(System.Drawing.Graphics g, int intMarginLeft, int intMarginTop, int intWidth, int intHeight)
        {
            Pen myPen = new Pen(Color.Black);
            myPen.Width = 2;
            // Create array of points that define lines to draw.
            int marginleft = intMarginLeft;
            int marginTop = intMarginTop;
            int width = intWidth;
            int height = intHeight;
            int arrowSize = 3;
            Point[] points =
             {
                new Point(marginleft, marginTop),
                new Point(marginleft, height + marginTop),
                new Point(marginleft + width, marginTop + height),
                // Arrow
                new Point(marginleft + width - arrowSize, marginTop + height - arrowSize),
                new Point(marginleft + width - arrowSize, marginTop + height + arrowSize),
                new Point(marginleft + width, marginTop + height)
             };

            g.DrawLines(myPen, points);
        }

        public void DrawGrid(System.Drawing.Graphics g)
        {
            Pen myPen = new Pen(new SolidBrush(Color.FromArgb(64, 0, 0, 0)));
            myPen.Width = 2;
            Brush highlightBrush = new SolidBrush(Color.FromArgb(196, 255, 165, 0));

            int normalisedZoom = (32 / zoomFactor);

            for (int y = 0; y < renderYSize * normalisedZoom; y++)
            {
                for (int x = 0; x < renderXSize * normalisedZoom; x++)
                {
                    int xx = x + cameraXMin;
                    int yy = y + cameraYMin;

                    Brush brush = new SolidBrush(pointList[yy * mapHeight + xx].brush);
                    Rectangle rec = pointList[yy * mapHeight + xx].rectangle;
                    Rectangle normalisedRectangle = new Rectangle((pointList[yy * mapHeight + xx].rectangle.Left) - (cameraXMin * zoomFactor), (pointList[yy * mapHeight + xx].rectangle.Top) - (cameraYMin * zoomFactor), zoomFactor, zoomFactor);

                    if (zoomFactor == 16)
                    {
                        //    Rectangle normalisedRectangle1 = new Rectangle((pointList[yy * mapHeight + xx].rectangle.Left) - (cameraXMin * zoomFactor) + 16, (pointList[yy * mapHeight + xx].rectangle.Top) - (cameraYMin * zoomFactor), zoomFactor, zoomFactor);
                        //    g.DrawRectangle(myPen, normalisedRectangle1);
                    }

                    if (zoomFactor == 32)
                    {
                        if (pointList[yy * mapHeight + xx].tile == status.wall || pointList[yy * mapHeight + xx].tile == status.moveableWall) { g.FillRectangle(brush, normalisedRectangle); }
                        if (highlightCreation && pointList[yy * mapHeight + xx].creationCode != "" && pointList[yy * mapHeight + xx].creationCode != "// This code is generated by LoF\n//Creation code for object: " + pointList[yy * mapHeight + xx].id + "\n") { g.FillRectangle(highlightBrush, pointList[yy * mapHeight + xx].rectangle); }
                    }

                    if (pointList[yy * mapHeight + xx].image != free) { g.DrawImage(pointList[yy * mapHeight + xx].image, x * zoomFactor, y * zoomFactor, zoomFactor, zoomFactor); }

                    if (zoomFactor == 32)
                    {
                        g.DrawRectangle(myPen, normalisedRectangle);
                    }
                }
            }
        }

        private void timer1_Tick(object sender, EventArgs e)
        {
            timer1.Enabled = true;
            timer1.Interval = 10;


            int x = (PointToClient(Cursor.Position).X / zoomFactor) + cameraXMin;
            int y = (PointToClient(Cursor.Position).Y / zoomFactor) + cameraYMin;

            label1.Text = "Mouse X: " + x + "\nMouse Y: " + y;

            try
            {
                Tile tile = pointList[y * mapHeight + x];
                Rectangle normalisedRectangle = new Rectangle((pointList[y * mapHeight + x].rectangle.Left * (zoomFactor / 32)) - (cameraXMin * zoomFactor), (pointList[y * mapHeight + x].rectangle.Top * (zoomFactor / 32)) - (cameraYMin * zoomFactor), zoomFactor, zoomFactor);
                rec = normalisedRectangle;
            }
            catch
            {
#warning Mouse exited grid area;
            }

            this.Invalidate();


        }

        private void Form1_MouseMove(object sender, MouseEventArgs e)
        {
            int x = PointToClient(Cursor.Position).X / zoomFactor;
            int y = PointToClient(Cursor.Position).Y / zoomFactor;

            mouseX = x;
            mouseY = y;

            if (x != prevX || y != prevY)
            {
                prevX = x;
                prevY = y;
                HandleMouseClick(sender, e);
            }
        }

        private void Form1_MouseDown(object sender, MouseEventArgs e)
        {
            prevX = -1;
            prevY = -1;
        }

        private void Form1_MouseUp(object sender, MouseEventArgs e)
        {
            //  HandleMouseClick(sender, e);
        }

        enum objects
        {
            Wall, MoveableWall, Player, Item, Coin, Enemy
        };

        private void comboBox1_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (comboBox1.SelectedIndex == (int)objects.Wall)
            {
                oThumnail.Image = Image.FromFile("wallThumbnail.png");
            }

            if (comboBox1.SelectedIndex == (int)objects.MoveableWall)
            {
                oThumnail.Image = Image.FromFile("wallMoveableThumnail.png");
            }

            if (comboBox1.SelectedIndex == (int)objects.Coin)
            {
                oThumnail.Image = Image.FromFile("coinThumbnail.png");
            }

            if (comboBox1.SelectedIndex == (int)objects.Player)
            {
                oThumnail.Image = Image.FromFile("playerThumbnail.png");
            }
        }

        private void oSave_Click(object sender, EventArgs e)
        {
            StreamWriter sw = new StreamWriter("savedMap.txt");

            for (int y = 0; y < mapHeight; y++)
            {
                for (int x = 0; x < mapWidth; x++)
                {
                    Tile tile = pointList[y * mapHeight + x];

                    if (tile.tile == status.free)
                    {
                        sw.WriteLine("[blank]");
                    }

                    if (tile.tile == status.wall)
                    {
                        List<string> csvParameters = getCsv(tile);

                        sw.WriteLine("[oWall]");
                        foreach (string ln in csvParameters)
                        {
                            sw.WriteLine(ln);
                        }
                        sw.WriteLine("/[oWall]");
                    }

                    if (tile.tile == status.coin)
                    {
                        List<string> csvParameters = getCsv(tile);

                        sw.WriteLine("[oGold]");
                        foreach (string ln in csvParameters)
                        {
                            sw.WriteLine(ln);
                        }
                        sw.WriteLine("/[oGold]");
                    }

                    if (tile.tile == status.moveableWall)
                    {
                        List<string> csvParameters = getCsv(tile);

                        sw.WriteLine("[oMoveableWall]");
                        foreach (string ln in csvParameters)
                        {
                            sw.WriteLine(ln);
                        }
                        sw.WriteLine("/[oMoveableWall]");
                    }

                    if (tile.tile == status.player)
                    {
                        List<string> csvParameters = getCsv(tile);

                        sw.WriteLine("[oPlayer]");
                        foreach (string ln in csvParameters)
                        {
                            sw.WriteLine(ln);
                        }
                        sw.WriteLine("/[oPlayer]");
                    }

                }

                sw.WriteLine("#NewLine");
            }

            sw.Close();
        }

        List<string> getCsv(Tile tile)
        {
            List<string> toReturn = new List<string>();

            using (StringReader reader = new StringReader(tile.creationCode))
            {
                string line;
                while ((line = reader.ReadLine()) != null)
                {
                    toReturn.Add(line);
                }
            }


            return toReturn;
        }

        private void oLoad_Click(object sender, EventArgs e)
        {
            StreamReader sr = new StreamReader("savedMap.txt");
            bool parsingEntity = false;
            string parsingEntityTitle = "";
            string line;
            int xx = 0; int yy = 0;
            Tile parsingTile = new Tile(status.free, Color.Black, new Rectangle(), free);
            parsingTile.creationCode = "";

            while ((line = sr.ReadLine()) != null)
            {
                if (parsingEntity == false)
                {
                    if (line == "[blank]")
                    {
                        grid[xx, yy] = status.free;
                        pointList[yy * mapHeight + xx].creationCode = "";
                        pointList[yy * mapHeight + xx].image = free;
                        pointList[yy * mapHeight + xx].tile = status.free;
                        parsingTile = new Tile(status.free, Color.Black, new Rectangle(), free); parsingTile.creationCode = "";
                        xx++;
                        continue;
                    }
                    else if (line == "#NewLine") { xx = 0; yy++; parsingTile = new Tile(status.free, Color.Black, new Rectangle(), free); parsingTile.creationCode = ""; continue; }
                    else if (line == "[oWall]" || line == "[oGold]" || line == "[oMoveableWall]" || line == "[oPlayer]")
                    {
                        parsingEntity = true;
                        parsingEntityTitle = line;
                    }
                }
                else
                {
                    if (line != "/" + parsingEntityTitle)
                    {
                        parsingTile.creationCode += line + "\n";
                    }
                    else
                    {

                        if (parsingEntityTitle == "[oGold]")
                        {
                            parsingTile.image = contentCoin;
                            parsingTile.tile = status.coin;

                        }
                        if (parsingEntityTitle == "[oPlayer]")
                        {
                            parsingTile.image = contentPlayer;
                            parsingTile.tile = status.player;

                        }
                        if (parsingEntityTitle == "[oWall]")
                        {
                            parsingTile.image = contentWall;
                            parsingTile.tile = status.wall;
                        }
                        if (parsingEntityTitle == "[oMoveableWall]")
                        {
                            parsingTile.image = contentMoveableWall;
                            parsingTile.tile = status.moveableWall;
                        }

                        grid[xx, yy] = parsingTile.tile;
                        pointList[yy * mapHeight + xx].creationCode = parsingTile.creationCode;
                        pointList[yy * mapHeight + xx].image = parsingTile.image;
                        pointList[yy * mapHeight + xx].brush = parsingTile.brush;
                        pointList[yy * mapHeight + xx].tile = parsingTile.tile;
                        ParseCode(parsingTile.creationCode, yy * 64 + xx);

                        xx++;
                        parsingEntityTitle = "";
                        parsingTile.creationCode = "";
                        parsingEntity = false;
                    }
                }

            }

            sr.Close();
            // Invalidate();

        }

        public void ParseCode(string code, int tileIndex)
        {
            string[] tokens = Regex.Split(code, @"\r?\n|\r");

            foreach (string line in tokens)
            {
                string ln = line;

                ln = line.Replace("=", "");
                ln = line.Replace(" ", "");
                ln = line.Replace(";", "");

                if (line.StartsWith("color"))
                {
                    ln = line.Replace("color", "");

                    if (ln.Contains("clRed"))
                    {
                        pointList[tileIndex].brush = Color.Red;
                    }
                    if (ln.Contains("clBlue"))
                    {
                        pointList[tileIndex].brush = Color.Blue;
                    }
                    if (ln.Contains("clGreen"))
                    {
                        pointList[tileIndex].brush = Color.Green;
                    }
                }

                if (line.StartsWith("saveBookmark"))
                {
                    ln = line.Replace("saveBookmark ", "");
                    Pos pos = new Pos(pointList[tileIndex].rectangle.Left / 32, pointList[tileIndex].rectangle.Top / 32, ln + "(" + pointList[tileIndex].rectangle.Left / 32 + "," + pointList[tileIndex].rectangle.Top / 32 + ")");
                    oBookmarks.Items.Add(pos);
                }
            }
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            toolTip1.SetToolTip(this.oLoad, "Načte zadanou mapu");
        }

        private void Form1_KeyPress(object sender, KeyPressEventArgs e)
        {

        }

        private void comboBox1_KeyPress(object sender, KeyPressEventArgs e)
        {
            if (e.KeyChar == 'c')
            {
                highlightCreation = !highlightCreation;
                if (highlightCreation) { MessageBox.Show("True"); }
            }
        }

        private void checkBox1_CheckedChanged(object sender, EventArgs e)
        {
            highlightCreation = checkBox1.Checked;
        }

        private void Form1_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.D && cameraXMax < mapWidth)
            {
                cameraXMax++;
                cameraXMin++;
                setCameraDebug();

            }

            if (e.KeyCode == Keys.A && cameraXMin > 0)
            {
                cameraXMax--;
                cameraXMin--;
                setCameraDebug();
            }

            if (e.KeyCode == Keys.W && cameraYMin > 0)
            {
                cameraYMax--;
                cameraYMin--;
                setCameraDebug();
            }

            if (e.KeyCode == Keys.S && cameraYMax < mapHeight)
            {
                cameraYMax++;
                cameraYMin++;
                setCameraDebug();

            }

            if (e.Control && e.KeyCode == Keys.C)
            {
                tempTile = pointList[mouseY * mapHeight + mouseX];
                LogEvent("Uložena entita " + tempTile.id + " (" + mouseX + "," + mouseY + ")", 3);
            }

            if (e.Control && e.KeyCode == Keys.V)
            {
                Rectangle aRec = new Rectangle(mouseX * 32, mouseY * 32, 32, 32);

                Tile pasteTile = new Tile(tempTile.tile, tempTile.brush, aRec, tempTile.image);
                pasteTile.creationCode = tempTile.creationCode;

                pointList[mouseY * mapHeight + mouseX] = pasteTile;
                grid[mouseX, mouseY] = tempTile.tile;
                LogEvent("Vložena entita " + tempTile.id + " (" + mouseX + "," + mouseY + ")", 3);
            }

            e.SuppressKeyPress = true;
        }

        void setCameraDebug()
        {
            this.oCamera.Text = "Camera INFO\nX: " + cameraXMin + " to " + cameraXMax + "\nY: " + cameraYMin + " to " + cameraYMax;
        }

        T[,] Resize2DArray<T>(T[,] original, int rows, int cols)
        {
            var newArray = new T[rows, cols];
            int minRows = Math.Min(rows, original.GetLength(0));
            int minCols = Math.Min(cols, original.GetLength(1));

            for (int i = 0; i < minRows; i++)
            {
                for (int j = 0; j < minCols; j++)
                {
                    newArray[i, j] = original[i, j];
                }
            }

            return newArray;
        }

        private void button1_Click(object sender, EventArgs e)
        {
            if (zoomFactor == 32)
            {
                zoomFactor = 16;
                button1.Text = "Zoom (0.5x)";
            }
            else
            {
                zoomFactor = 32;
                button1.Text = "Zoom (1x)";
            }
        }

        private void hScrollBar1_Scroll(object sender, ScrollEventArgs e)
        {
            int normalisedValue = Math.Min(hScrollBar1.Value, mapWidth);

            cameraXMin = normalisedValue;
            cameraXMax = Math.Min(normalisedValue + renderXSize, mapWidth);
            setCameraDebug();
        }

        private void vScrollBar1_Scroll(object sender, ScrollEventArgs e)
        {
            int normalisedValue = Math.Min(vScrollBar1.Value, mapHeight);

            cameraYMin = normalisedValue;
            cameraYMax = Math.Min(normalisedValue + renderYSize, mapHeight);
            setCameraDebug();
        }

        private void groupBox1_Enter(object sender, EventArgs e)
        {

        }

        private void oBookmarks_SelectedIndexChanged(object sender, EventArgs e)
        {
            int centerX = renderXSize / 2;
            int centerY = renderYSize / 2;

            Pos indexPos = (Pos)oBookmarks.SelectedItem;
            cameraXMin = Math.Max(indexPos.x - centerX, 0);
            cameraXMax = indexPos.x + centerX;

            cameraYMin = Math.Max(indexPos.y - centerY, 0);
            cameraYMax = indexPos.y + centerY;

            setCameraDebug();

            hScrollBar1.Value = indexPos.x;
            vScrollBar1.Value = indexPos.y;
        }

        private void EventLogTimer_Tick(object sender, EventArgs e)
        {
            int fadingSpeed = animationSpeed;

            if (animationOffset > 0) { animationOffset -= animationSpeed; }
            else
            {
                oEventLog.ForeColor = Color.FromArgb(oEventLog.ForeColor.R + fadingSpeed, oEventLog.ForeColor.R + fadingSpeed, oEventLog.ForeColor.G + fadingSpeed, oEventLog.ForeColor.B + fadingSpeed);
            }

            if (oEventLog.ForeColor.R >= this.BackColor.R)
            {
                EventLogTimer.Stop();
                oEventLog.ForeColor = this.BackColor;
                animationOffset = 200;
                //oEventLog.Visible = false;
            }
        }

        void LogEvent(string text, int animationSpeed)
        {
            this.animationSpeed = animationSpeed;
            oEventLog.Visible = true;
            oEventLog.ForeColor = Color.FromArgb(255, Color.Black);
            oEventLog.Text = text;
            EventLogTimer.Start();
        }

        private void treeView1_AfterSelect(object sender, TreeViewEventArgs e)
        {
            LogEvent(treeView1.SelectedNode.ToString(), 3);

            if (treeView1.SelectedNode == terrainNode.Nodes["Zeď"])
            {
                LogEvent("Vybráno: Zeď", 3);
                comboBox1.SelectedItem = "Zeď";
            }

            if (treeView1.SelectedNode == terrainNode.Nodes["Pohyblivá zeď"])
            {
                LogEvent("Vybráno: Pohyblivá zeď", 3);
                comboBox1.SelectedItem = "Pohyblivá zeď";
            }

            if (treeView1.SelectedNode == itemNode.Nodes["Mince"])
            {
                LogEvent("Vybráno: Mince", 3);
                comboBox1.SelectedItem = "Mince";
            }

            if (treeView1.SelectedNode == actorsNode.Nodes["Hráč"])
            {
                LogEvent("Vybráno: Hráč", 3);
                comboBox1.SelectedItem = "Hráč";
            }
        }

        void AddNodes()
        {
            treeView1.Nodes.Add(terrainNode);
            treeView1.Nodes.Add(actorsNode);
            treeView1.Nodes.Add(itemNode);

            // Child nodes
            AdvancedNode terrainNodeWall = new AdvancedNode("Zeď");
            terrainNode.Nodes.Add(terrainNodeWall);

            AdvancedNode terrainNodeWallMoveable = new AdvancedNode("Pohyblivá zeď");
            terrainNode.Nodes.Add(terrainNodeWallMoveable);

            AdvancedNode itemNodeCoin = new AdvancedNode("Mince");
            itemNode.Nodes.Add(itemNodeCoin);

            AdvancedNode actorNodePlayer = new AdvancedNode("Hráč");
            actorsNode.Nodes.Add(actorNodePlayer);

            AdvancedNode actorNodeGoblin = new AdvancedNode("Goblin");
            actorsNode.Nodes.Add(actorNodeGoblin);

        }

        private void oExport_Click(object sender, EventArgs e)
        {

            StreamWriter sw = new StreamWriter("map.RetroRpgMap");

            for (int y = 0; y < mapHeight; y++)
            {
                for (int x = 0; x < mapWidth; x++)
                {
                    Tile tile = pointList[y * mapHeight + x];

                    if (tile.tile == status.free)
                    {
                        sw.WriteLine("[blank]");
                    }

                    if (tile.tile == status.wall)
                    {
                        List<string> csvParameters = getCsv(tile);

                        sw.Write("[oWall]");

                        if (csvParameters.Count > 0)
                        {
                            sw.Write("[");
                            foreach (string ln in csvParameters)
                            {                             
                                sw.Write(ln + ";");
                            }
                            sw.Write("]");                   
                        }

                        sw.WriteLine();
                    }

                    if (tile.tile == status.coin)
                    {
                        List<string> csvParameters = getCsv(tile);

                        sw.Write("[oGold]");

                        if (csvParameters.Count > 0)
                        {
                            sw.Write("[");
                            foreach (string ln in csvParameters)
                            {
                                sw.Write(ln + ";");
                            }
                            sw.Write("]");
                        }

                        sw.WriteLine();
                    }

                    if (tile.tile == status.moveableWall)
                    {
                        List<string> csvParameters = getCsv(tile);

                        sw.Write("[oMoveableWall]");

                        if (csvParameters.Count > 0)
                        {
                            sw.Write("[");
                            foreach (string ln in csvParameters)
                            {
                                sw.Write(ln + ";");
                            }
                            sw.Write("]");
                        }

                        sw.WriteLine();
                    }

                    if (tile.tile == status.player)
                    {
                        List<string> csvParameters = getCsv(tile);

                        sw.Write("[oPlayer]");

                        if (csvParameters.Count > 0)
                        {
                            sw.Write("[");
                            foreach (string ln in csvParameters)
                            {
                                sw.Write(ln + ";");
                            }
                            sw.Write("]");
                        }

                        sw.WriteLine();
                    }

                }

                sw.WriteLine("#NewLine");
            }

            sw.Close();
        }

        private void oNewMap_Click(object sender, EventArgs e)
        {
            NewMap testDialog = new NewMap(this);

            if (testDialog.ShowDialog(this) == DialogResult.Cancel)
            {
                int prevWidth = mapWidth;
                int prevHeight = mapHeight;

                mapWidth = Convert.ToInt32(testDialog.textBox1.Text);
                mapHeight = Convert.ToInt32(testDialog.textBox2.Text);

                vScrollBar1.Maximum = mapWidth;
                hScrollBar1.Maximum = mapHeight;

                grid = new status[mapWidth, mapHeight];
                for (int y = 0; y < mapHeight; y++)
                {
                    for (int x = 0; x < mapWidth; x++)
                    {
                        grid[x, y] = status.free;
                    }
                }

                for (int y = 0; y < mapHeight; y++)
                {
                    for (int x = 0; x < mapWidth; x++)
                    {
                        if (x >= prevWidth || y >= prevHeight)
                        {
                            Tile tile = new Tile(status.free, Color.Black, rec, free);
                            pointList.Add(tile);
                        }

                        Tile tl = pointList[y * mapHeight + x];
                        tl.creationCode = "";
                        tl.image = free;
                        tl.tile = status.free;
                    }
                }

            }

            testDialog.Dispose();
        }
    } 
}
